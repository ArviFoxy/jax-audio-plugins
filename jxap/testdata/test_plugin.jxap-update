#loc = loc(unknown)
#loc11 = loc("state[0]")
#loc12 = loc("state[1]")
#loc13 = loc("buffers['input']")
#loc14 = loc("sample_rate")
module @jit__update_fn attributes {jax.uses_shape_polymorphism = true, mhlo.num_partitions = 1 : i32, mhlo.num_replicas = 1 : i32} {
  func.func public @main(%arg0: tensor<i32> {jax.global_constant = "_platform_index"} loc(unknown), %arg1: tensor<f32> loc(unknown), %arg2: tensor<?xf32> loc(unknown), %arg3: tensor<?xf32> loc(unknown), %arg4: tensor<f32> loc(unknown)) -> (tensor<f32> {jax.result_info = "result[0][0]"}, tensor<?xf32> {jax.result_info = "result[0][1]"}, tensor<?xf32> {jax.result_info = "result[1]['output']"}) {
    %c = stablehlo.constant dense<0> : tensor<i32> loc(#loc)
    %c_0 = stablehlo.constant dense<-1> : tensor<i32> loc(#loc)
    %c_1 = stablehlo.constant dense<1> : tensor<i32> loc(#loc)
    %0 = stablehlo.get_dimension_size %arg2, dim = 0 : (tensor<?xf32>) -> tensor<i32> loc(#loc62)
    %1 = stablehlo.get_dimension_size %arg3, dim = 0 : (tensor<?xf32>) -> tensor<i32> loc(#loc62)
    %2 = stablehlo.compare  GE, %0, %c_1,  SIGNED : (tensor<i32>, tensor<i32>) -> tensor<i1> loc(#loc63)
    stablehlo.custom_call @shape_assertion(%2, %0) {api_version = 2 : i32, error_message = "Input shapes do not match the polymorphic shapes specification. Expected value >= 1 for dimension variable 'BufferSize'. Using the following polymorphic shapes specifications: args[0][1].shape = (BufferSize,),args[1]['input'].shape = (BufferSize,). Obtained dimension variables: 'BufferSize' = {0} from specification 'BufferSize' for dimension args[0][1].shape[0] (= {0}), . Please see https://docs.jax.dev/en/latest/export/shape_poly.html#shape-assertion-errors for more details.", has_side_effect = true} : (tensor<i1>, tensor<i32>) -> () loc(#loc64)
    %3 = stablehlo.compare  EQ, %1, %0,  SIGNED : (tensor<i32>, tensor<i32>) -> tensor<i1> loc(#loc65)
    stablehlo.custom_call @shape_assertion(%3, %1, %0) {api_version = 2 : i32, error_message = "Input shapes do not match the polymorphic shapes specification. Found inconsistency between dimension size args[1]['input'].shape[0] (= {0}) and the specification 'BufferSize' (= {1}). Using the following polymorphic shapes specifications: args[0][1].shape = (BufferSize,),args[1]['input'].shape = (BufferSize,). Obtained dimension variables: 'BufferSize' = {1} from specification 'BufferSize' for dimension args[0][1].shape[0] (= {1}), . Please see https://docs.jax.dev/en/latest/export/shape_poly.html#shape-assertion-errors for more details.", has_side_effect = true} : (tensor<i1>, tensor<i32>, tensor<i32>) -> () loc(#loc64)
    %4 = stablehlo.convert %0 : tensor<i32> loc(#loc66)
    %5 = stablehlo.add %4, %c_0 : tensor<i32> loc(#loc67)
    %6 = stablehlo.compare  GE, %5, %c,  SIGNED : (tensor<i32>, tensor<i32>) -> tensor<i1> loc(#loc63)
    %7 = stablehlo.convert %0 : tensor<i32> loc(#loc66)
    %8 = stablehlo.add %7, %c_0 : tensor<i32> loc(#loc67)
    stablehlo.custom_call @shape_assertion(%6, %8, %0) {api_version = 2 : i32, error_message = "Input shapes do not match the symbolic shape constraint BufferSize >= 1. Expected 'BufferSize - 1' to be greater or equal to 0, but found {0}.  Using the following polymorphic shapes specifications: args[0][1].shape = (BufferSize,),args[1]['input'].shape = (BufferSize,). Obtained dimension variables: 'BufferSize' = {1} from specification 'BufferSize' for dimension args[0][1].shape[0] (= {1}), . Please see https://docs.jax.dev/en/latest/export/shape_poly.html#shape-assertion-errors for more details.", has_side_effect = true} : (tensor<i1>, tensor<i32>, tensor<i32>) -> () loc(#loc64)
    %9:3 = call @_wrapped_jax_export_main(%arg0, %0, %arg1, %arg2, %arg3, %arg4) : (tensor<i32>, tensor<i32>, tensor<f32>, tensor<?xf32>, tensor<?xf32>, tensor<f32>) -> (tensor<f32>, tensor<?xf32>, tensor<?xf32>) loc(#loc)
    return %9#0, %9#1, %9#2 : tensor<f32>, tensor<?xf32>, tensor<?xf32> loc(#loc)
  } loc(#loc)
  func.func private @_wrapped_jax_export_main(%arg0: tensor<i32> {jax.global_constant = "_platform_index"} loc(unknown), %arg1: tensor<i32> {jax.global_constant = "BufferSize"} loc(unknown), %arg2: tensor<f32> loc("state[0]"), %arg3: tensor<?xf32> loc("state[1]"), %arg4: tensor<?xf32> loc("buffers['input']"), %arg5: tensor<f32> loc("sample_rate")) -> (tensor<f32> {jax.result_info = "result[0][0]"}, tensor<?xf32> {jax.result_info = "result[0][1]"}, tensor<?xf32> {jax.result_info = "result[1]['output']"}) {
    %c = stablehlo.constant dense<0> : tensor<i32> loc(#loc)
    %c_0 = stablehlo.constant dense<-1> : tensor<i32> loc(#loc)
    %c_1 = stablehlo.constant dense<1> : tensor<i32> loc(#loc)
    %0 = stablehlo.broadcast_in_dim %c_1, dims = [] : (tensor<i32>) -> tensor<1xi32> loc(#loc68)
    %1 = stablehlo.convert %arg1 : tensor<i32> loc(#loc69)
    %2 = stablehlo.add %1, %c_0 : tensor<i32> loc(#loc70)
    %3 = stablehlo.reshape %2 : (tensor<i32>) -> tensor<1xi32> loc(#loc71)
    %4 = "stablehlo.dynamic_gather"(%arg4, %0, %3) <{dimension_numbers = #stablehlo.gather<offset_dims = [0], start_index_map = [0]>, indices_are_sorted = true}> : (tensor<?xf32>, tensor<1xi32>, tensor<1xi32>) -> tensor<?xf32> loc(#loc71)
    %5 = stablehlo.broadcast_in_dim %arg2, dims = [] : (tensor<f32>) -> tensor<1xf32> loc(#loc72)
    %6 = stablehlo.convert %5 : tensor<1xf32> loc(#loc73)
    %7 = stablehlo.concatenate %4, %6, dim = 0 : (tensor<?xf32>, tensor<1xf32>) -> tensor<?xf32> loc(#loc74)
    %8 = stablehlo.add %arg4, %7 : tensor<?xf32> loc(#loc75)
    %9 = stablehlo.add %8, %arg3 : tensor<?xf32> loc(#loc76)
    %10 = stablehlo.broadcast_in_dim %c, dims = [] : (tensor<i32>) -> tensor<1xi32> loc(#loc77)
    %11 = "stablehlo.gather"(%arg4, %10) <{dimension_numbers = #stablehlo.gather<collapsed_slice_dims = [0], start_index_map = [0]>, indices_are_sorted = true, slice_sizes = array<i64: 1>}> : (tensor<?xf32>, tensor<1xi32>) -> tensor<f32> loc(#loc78)
    return %11, %arg4, %9 : tensor<f32>, tensor<?xf32>, tensor<?xf32> loc(#loc)
  } loc(#loc)
} loc(#loc)
#loc1 = loc("/workspaces/jxap/python/jax_audio_plugins/export.py":108:25 to 109:69)
#loc2 = loc("/workspaces/jxap/python/jax_audio_plugins/export_test.py":50:8 to :49)
#loc3 = loc("/workspaces/.venv/lib/python3.11/site-packages/absl/testing/_pretty_print_reporter.py":84:13 to :30)
#loc4 = loc("/workspaces/.venv/lib/python3.11/site-packages/absl/testing/absltest.py":2793:19 to :56)
#loc5 = loc("/workspaces/.venv/lib/python3.11/site-packages/absl/testing/absltest.py":2829:35 to 2831:3)
#loc6 = loc("/workspaces/.venv/lib/python3.11/site-packages/absl/testing/absltest.py":2373:6 to :34)
#loc7 = loc("/workspaces/.venv/lib/python3.11/site-packages/absl/app.py":261:13 to :23)
#loc8 = loc("/workspaces/.venv/lib/python3.11/site-packages/absl/app.py":316:6 to :27)
#loc9 = loc("/workspaces/.venv/lib/python3.11/site-packages/absl/testing/absltest.py":2375:4 to :31)
#loc10 = loc("/workspaces/.venv/lib/python3.11/site-packages/absl/testing/absltest.py":2269:2 to :38)
#loc15 = loc("/workspaces/jxap/python/jax_audio_plugins/export_test.py":39:31 to :36)
#loc16 = loc("/workspaces/jxap/python/jax_audio_plugins/export.py":102:29 to :71)
#loc17 = loc("/workspaces/jxap/python/jax_audio_plugins/export_test.py":39:38 to :68)
#loc18 = loc("/workspaces/jxap/python/jax_audio_plugins/export_test.py":39:14 to :78)
#loc19 = loc("/workspaces/jxap/python/jax_audio_plugins/export_test.py":40:12 to :19)
#loc20 = loc("/workspaces/jxap/python/jax_audio_plugins/export_test.py":40:12 to :39)
#loc21 = loc("/workspaces/jxap/python/jax_audio_plugins/export_test.py":41:48 to :52)
#loc22 = loc("export_plugin"(#loc1))
#loc23 = loc("ExportingTest.test_export_plugin"(#loc2))
#loc24 = loc("TextTestRunner.run"(#loc3))
#loc25 = loc("_run_and_get_tests_result"(#loc4))
#loc26 = loc("run_tests"(#loc5))
#loc27 = loc("_run_in_app.<locals>.main_function"(#loc6))
#loc28 = loc("_run_main"(#loc7))
#loc29 = loc("run"(#loc8))
#loc30 = loc("_run_in_app"(#loc9))
#loc31 = loc("main"(#loc10))
#loc32 = loc("TestPlugin.update"(#loc15))
#loc33 = loc("export_plugin.<locals>._update_fn"(#loc16))
#loc34 = loc("TestPlugin.update"(#loc17))
#loc35 = loc("TestPlugin.update"(#loc18))
#loc36 = loc("TestPlugin.update"(#loc19))
#loc37 = loc("TestPlugin.update"(#loc20))
#loc38 = loc("TestPlugin.update"(#loc21))
#loc39 = loc(callsite(#loc30 at #loc31))
#loc40 = loc(callsite(#loc28 at #loc29))
#loc41 = loc(callsite(#loc29 at #loc39))
#loc42 = loc(callsite(#loc27 at #loc40))
#loc43 = loc(callsite(#loc28 at #loc41))
#loc44 = loc(callsite(#loc26 at #loc42))
#loc45 = loc(callsite(#loc27 at #loc43))
#loc46 = loc(callsite(#loc25 at #loc44))
#loc47 = loc(callsite(#loc26 at #loc45))
#loc48 = loc(callsite(#loc24 at #loc46))
#loc49 = loc(callsite(#loc25 at #loc47))
#loc50 = loc(callsite(#loc23 at #loc48))
#loc51 = loc(callsite(#loc24 at #loc49))
#loc52 = loc(callsite(#loc22 at #loc50))
#loc53 = loc(callsite(#loc23 at #loc51))
#loc54 = loc(callsite(#loc33 at #loc52))
#loc55 = loc(callsite(#loc22 at #loc53))
#loc56 = loc(callsite(#loc32 at #loc54))
#loc57 = loc(callsite(#loc34 at #loc54))
#loc58 = loc(callsite(#loc35 at #loc54))
#loc59 = loc(callsite(#loc36 at #loc54))
#loc60 = loc(callsite(#loc37 at #loc54))
#loc61 = loc(callsite(#loc38 at #loc54))
#loc62 = loc("/dimension_size"(#loc55))
#loc63 = loc("/ge"(#loc55))
#loc64 = loc("/shape_assertion"(#loc55))
#loc65 = loc("/eq"(#loc55))
#loc66 = loc("/convert_element_type"(#loc55))
#loc67 = loc("/add"(#loc55))
#loc68 = loc("jit(_update_fn)/jit(main)/broadcast_in_dim"(#loc56))
#loc69 = loc("jit(_update_fn)/jit(main)/convert_element_type"(#loc56))
#loc70 = loc("jit(_update_fn)/jit(main)/add"(#loc56))
#loc71 = loc("jit(_update_fn)/jit(main)/gather"(#loc56))
#loc72 = loc("jit(_update_fn)/jit(main)/broadcast_in_dim"(#loc57))
#loc73 = loc("jit(_update_fn)/jit(main)/convert_element_type"(#loc58))
#loc74 = loc("jit(_update_fn)/jit(main)/concatenate"(#loc58))
#loc75 = loc("jit(_update_fn)/jit(main)/add"(#loc59))
#loc76 = loc("jit(_update_fn)/jit(main)/add"(#loc60))
#loc77 = loc("jit(_update_fn)/jit(main)/broadcast_in_dim"(#loc61))
#loc78 = loc("jit(_update_fn)/jit(main)/gather"(#loc61))
